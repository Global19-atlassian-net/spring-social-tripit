<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="implementing" xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>Adding support for a service provider</title>
	<para>
		Spring Social makes it easy to add support for service providers that are not already supported by the framework.
		If you review the existing client modules, such as spring-social-twitter and spring-social-facebook, you will discover they are implemented in a consistent manner and they apply a set of well-defined extension points.
		In this section, you will learn how to add support for new service providers you wish to integrate into your applications.
	</para>
	<section id="service-providers-implementing">
		<title>Process</title>
		<para>
			The process of adding client support for a service provider consists of several steps:
			<orderedlist>
				<listitem>
					<para>Create a source project for the client code e.g. <code>spring-social-twitter</code>.</para>
				</listitem>
				<listitem>
					<para>Develop or integrate a Java binding to the provider's "Service API" e.g. <code>TwitterApi</code>.</para>
				</listitem>
				<listitem>
					<para>Create a ServiceProvider implementation that allows users to authorize with the provider and obtain Service API instances e.g. <code>TwitterServiceProvider</code>.</para>
				</listitem>
				<listitem>
					<para>Create a ServiceApiAdapter that maps the provider's native Service API onto the uniform ServiceProviderConnection model e.g. <code>TwitterServiceApiAdapter</code>.</para>
				</listitem>
				<listitem>
					<para>Finally, create a ServiceProviderConnectionFactory that wraps the other artifacts up and provides a simple interface for establishing connections e.g. <code>TwitterServiceProviderConnectionFactory</code></para>
				</listitem>
			</orderedlist>
		</para>
		<para>
			The following sections of this chapter walk you through each of the steps with examples.
		</para>
	</section>
	<section id="service-providers-implementing-project">
		<title>Creating a source project for the provider client code</title>
		<para>
			A Spring Social provider client is simply a standard Java project that builds a jar artifact e.g. spring-social-twitter.jar.
			We do recommend the actual code structure follow several packaging guidelines described below.
			To make this as easy as possible to do, we have also created a template project you may use as a starting point.
		</para>
		<section id="service-providers-implementing-project-structure">
			<title>Code structure recommendations</title>
			<para>
				We recommend all code for a new Spring Social client module fall within the <code>org.springframework.social.{providerId}</code> base package,
				where {providerId} is the unique identifier you assign to the service provider you are adding support for.
				Consider some of the providers already supported by the framework as examples:
				<table xml:id="service-providers-implementing-project-structure-examples">
					<title>Spring Social Client Projects</title>
					<tgroup cols="3">
						<colspec align="left" />
						<colspec colnum="1" colname="col1" colwidth="2*" />
						<colspec colnum="2" colname="col2" colwidth="2*" />
						<colspec colnum="3" colname="col3" colwidth="2*" />
						<thead>
							<row>
								<entry align="center">Provider ID</entry>
								<entry align="center">Artifact Name</entry>
								<entry align="center">Base Package</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>facebook</entry>
								<entry>spring-social-facebook</entry>
								<entry>org.springframework.social.facebook</entry>
							</row>					
							<row>
								<entry>twitter</entry>
								<entry>spring-social-twitter</entry>
								<entry>org.springframework.social.twitter</entry>
							</row>					
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				Within the base package, we recommend the following subpackage structure:
				<table>
					<tgroup cols="2">
						<colspec align="left" />
						<colspec colnum="1" colname="col1" colwidth="2*" />
						<colspec colnum="2" colname="col2" colwidth="2*" />
						<thead>
							<row>
								<entry align="center">Subpackage</entry>
								<entry align="center">Description</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>api</entry>
								<entry>Contains the public interface defining the Java binding to the service provider's API.</entry>
							</row>					
							<row>
								<entry>api.impl</entry>
								<entry>Contains the primary implementation of the Java API binding.</entry>
							</row>					
							<row>
								<entry>connect</entry>
								<entry>Contains the types necessary to establish connections to the service provider.</entry>
							</row>					
						</tbody>					
					</tgroup>
				</table>
			</para>
			<para>
				You can see this recommended structure in action by reviewing one of the other client modules such as spring-social-twitter:`
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/spring-social-twitter-example.png" format="PNG" align="center" />
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/spring-social-twitter-example.png" format="PNG" align="center" />
					</imageobject>
				</mediaobject>
			</para>
			<para>
				Here, the central service API type, TwitterApi, is located in the api package along with its supporting operations types and data transfer object types.
				The primary implementation of that interface, TwitterTemplate, is located in the api.impl package (along with other package-private impl types have that been excluded from this view).
				Finally, the connect package contains the implementation of various connect SPIs that enable connections to the provider to be established and persisted.
			</para>
		</section>
	</section>
	<section id="service-providers-implementing-oauth2">
		<title>OAuth2 Service Providers</title>
		<para>
			To implement an OAuth2-based ServiceProvider, first extend AbstractOAuth2ServiceProvider.
			Parameterize &lt;S&gt; to be the Java Binding to the ServiceProvider API.
			Define a single constructor that accepts an clientId and clientSecret,
			Finally, implement getServiceApi(String) to return a new API instance.
		</para>
		<para>
			See FacebookServiceProvider as an example of an OAuth2-based ServiceProvider:
		</para>
		<programlisting language="java"><![CDATA[
public final class FacebookServiceProvider extends AbstractOAuth2ServiceProvider<FacebookApi> {

    public FacebookServiceProvider(String clientId, String clientSecret) {
        super(new OAuth2Template(clientId, clientSecret,
            "https://graph.facebook.com/oauth/authorize", 
            "https://graph.facebook.com/oauth/access_token"));
    }

    public FacebookApi getServiceApi(String accessToken) {
        return new FacebookTemplate(accessToken);
    }

}]]>
		</programlisting>
		<para>
			In the constructor, you should call super, passing up the configured OAuth2Template, which implements OAuth2Operations.
			The OAuth2Template will handle the "OAuth dance" with the provider, and should be configured with the provided clientId and clientSecret, along with the provider-specific authorizeUrl and accessTokenUrl.
		</para>
		<para>
			In getServiceApi(String), you should construct your Service API implementation, passing it the access token needed to make requests for protected resources.
			Inside the API implementation, we generally recommend using RestTemplate to make the HTTP calls and add the required Authorization header:
		</para>
		<programlisting language="java"><![CDATA[
public FacebookTemplate(String accessToken) {
    // creates a RestTemplate that adds the OAuth2-draft10 Authorization header to each request before it is executed
    restTemplate = ProtectedResourceClientFactory.draft10(accessToken);
}]]>
		</programlisting>
		<para>
			An example API call with RestTemplate is shown below:
		</para>
		<programlisting language="java"><![CDATA[
public FacebookProfile getUserProfile(String facebookId) {
    return new FacebookProfile(restTemplate.getForObject("https://graph.facebook.com/{facebookId}", Map.class, facebookId));
}]]>
		</programlisting>
	</section>
	<section id="service-providers-implementing-oauth1">
		<title>OAuth1 Service Providers</title>
		<para>
			To implement an OAuth1-based ServiceProvider, first extend AbstractOAuth1ServiceProvider.
			Parameterize &lt;S&gt; to be the Java Binding to the ServiceProvider API.
			Define a single constructor that accepts a consumerKey and consumerSecret.
			Finally, implement getServiceApi(String, String) to return a new API instance.
		</para>
		<para>
			See TwitterServiceProvider as an example of an OAuth1-based ServiceProvider:
		</para>
		<programlisting language="java"><![CDATA[
public final class TwitterServiceProvider extends AbstractOAuth1ServiceProvider<TwitterApi> {

    public TwitterServiceProvider(String consumerKey, String consumerSecret) {
        super(consumerKey, consumerSecret,  new OAuth1Template(consumerKey, consumerSecret, 
                "https://twitter.com/oauth/request_token",
                "https://twitter.com/oauth/authorize",
                "https://twitter.com/oauth/access_token"));
    }

    public TwitterApi getServiceApi(String accessToken, String secret) {
        return new TwitterTemplate(getConsumerKey(), getConsumerSecret(), accessToken, secret);
    }

}]]>
		</programlisting>
		<para>
			In the constructor, you should call super, passing up the the consumerKey, secret, and configured OAuth1Template.
			The OAuth1Template will handle the "OAuth dance" with the provider.
			It should be configured with the provided consumerKey and consumerSecret, along with the provider-specific requestTokenUrl, authorizeUrl, and accessTokenUrl.
		</para>			
		<para>
			In getServiceApi(String, String), you should construct your Service API implementation, passing it the four tokens needed to make requests for protected resources.
			Inside the API implementation, we generally recommend using RestTemplate to make the HTTP calls and add the required Authorization header:
		</para>
		<programlisting language="java"><![CDATA[
public TwitterTemplate(String consumerKey, String consumerSecret, String accessToken, String accessTokenSecret) {
    // creates a RestTemplate that adds the OAuth1 Authorization header to each request before it is executed
    restTemplate = ProtectedResourceClientFactory.create(consumerKey, consumerSecret, accessToken, accessTokenSecret);
}]]>
		</programlisting>
		<para>
			An example API call with RestTemplate is shown below:
		</para>
		<programlisting language="java"><![CDATA[
public TwitterProfile getUserProfile(String screenName) {
    return new TwitterProfile(restTemplate.getForObject("https://api.twitter.com/1/users/show.json?screen_name={screenName}", Map.class, screenName));
}]]>
		</programlisting>									
	</section>
</chapter>