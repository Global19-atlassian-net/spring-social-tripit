<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="serviceprovider"
    xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Service Provider Framework</title>

  <para>In Spring Social, a social service such as Twitter or Facebook is modeled as a service provider. With a service provider, an application may create/sever connections and obtain an API through which the application may interact with the service on a user's behalf.</para>

  <section xml:id="section_serviceproviderconfig">
      <title>Configuring Service Providers</title>
      
      <para>You can configure a service provider in the Spring application context using Spring Social's Spring configuration namespace:</para>
      
      <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:social="http://www.springframework.org/schema/spring-social"
    xsi:schemaLocation="http://www.springframework.org/schema/spring-social 
             http://www.springframework.org/schema/social/spring-social-1.0.xsd
        http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
        
    ...
</beans>]]></programlisting>

      <para>The <code><![CDATA[<social:service-provider>]]></code> element can be used to configure any service provider in Spring. For example, to configure a Twitter provider:</para>
      
<programlisting><![CDATA[<social:service-provider 
    class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
    client-key="..." 
    client-secret="..." />]]></programlisting>

      <para>The <code>client-key</code> and <code>client-secret</code> attributes specify the key and secret values assigned to your application when you registered it with the provider.</para>
            
      <para>The <code>class</code> attribute specifies the fully-qualified name of the provider implementation. Spring Social comes with several ready-to-use service provider implementations:</para>
      
      <itemizedlist>
          <listitem><para><classname>org.springframework.social.facebook.connect.FacebookServiceProvider</classname></para></listitem>
          <listitem><para><classname>org.springframework.social.github.connect.GitHubServiceProvider</classname></para></listitem>
          <listitem><para><classname>org.springframework.social.gowalla.connect.GowallaServiceProvider</classname></para></listitem>
          <listitem><para><classname>org.springframework.social.linkedin.connect.LinkedInServiceProvider</classname></para></listitem>
          <listitem><para><classname>org.springframework.social.tripit.connect.TripItServiceProvider</classname></para></listitem>
          <listitem><para><classname>org.springframework.social.twitter.connect.TwitterServiceProvider</classname></para></listitem>
      </itemizedlist>

      <para>You may also create your own service providers by implementing the <interfacename>ServiceProvider</interfacename> interface or extending either <classname>AbstractServiceProvider</classname>, <classname>AbstractOAuth1ServiceProvider</classname>, or <classname>AbstractOAuth2ServiceProvider</classname>.</para>

      <section xml:id="section_config_connectionrepository">
          <title>Connection Repository</title>
          
          <para>In addition to the service provider itself, you'll also need to configure a connection repository bean for service providers to persist connections. Spring Social comes with <classname>JdbcConnectionRepository</classname>, a connection repository that persists connections to a relational database via JDBC. The following XML shows how to configure a <classname>JdbcConnectionRepository</classname> bean:</para>
          
          <programlisting><![CDATA[<bean id="connectionRepository" class="org.springframework.social.connect.jdbc.JdbcConnectionRepository">
    <constructor-arg ref="dataSource" />
    <constructor-arg ref="textEncryptor" />
</bean>]]></programlisting>

          <para><classname>JdbcConnectionRepository</classname> is constructed with a reference to a <classname>DataSource</classname> through which it will communicate with the database and a <interfacename>TextEncryptor</interfacename> that it will use to encrypt/decrypt sensitive connection details (such as access tokens and secrets).</para>
          
          <para>The <interfacename>TextEncryptor</interfacename> is defined in Spring Security 3.1 in the <code>org.springframework.security.crypto.encrypt</code> package. Spring Security 3.1 also includes an <classname>Encryptors</classname> class which acts as a factory for common encryptor implementations. For example, to configure a no-op text encryptor (one that doesn't perform any encryption at all):</para>

          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" />]]></programlisting>
          
          <para>Or, to configure a text encryptor that uses standard password-based encryption:</para>
          
          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="text">
    <constructor-arg value="password"/>
    <constructor-arg value="salt"/>    
</bean>]]></programlisting>

          <para>Note that the ID of the connection repository bean is significant. By default, the <code><![CDATA[<social:service-provider>]]></code> element will assume that the connection repository bean's ID is "connectionRepository". If, however, you give the connection repository bean a different ID, then you'll need to specify the connection repository when configuring a <code><![CDATA[<social:service-provider>]]></code>:</para>

          <programlisting><![CDATA[<social:service-provider 
              class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
              client-key="..." 
              client-secret="..."
              connection-repository="connectionStorage" />]]></programlisting>
              
      </section>


  </section>
  <section xml:id="section_usingserviceproviders">
      <title>Using Service Providers</title>
      
      <para>Once you have a server provider configured in Spring, there are a handful of things you can do with the service provider, including:</para>
      
      <itemizedlist>
          <listitem><para>Manage connections between an application account and a provider profile.</para></listitem>
          <listitem><para>Access provider API for interacting with the service provider on behalf of the user.</para></listitem>
      </itemizedlist>
            
      <section xml:id="section_sp_manageConnections">
          <title>Managing provider connections</title>
          
          <para>The <interfacename>ServiceProvider</interfacename> interface affords a few methods for managing connections between an application account and a user's profile at the provider:</para>
          
          <programlisting><![CDATA[boolean isConnected(Serializable accountId);
List<ServiceProviderConnection<S>> getConnections(Serializable accountId);]]></programlisting>
          
          <para>The <methodname>isConnected()</methodname> method is useful for determining if any connections have been made between the user's application account (specified with the account ID) and the provider.</para>

          <para>To work with the connections themselves, call the <methodname>getConnections()</methodname> method. Notice that this method returns a list of <interfacename>ServiceProviderConnection</interfacename>s and not a single connection. That's because it is possible for a user to connect their account with multiple profiles on the provider. For example, if a user has multiple Twitter profiles, any one or all of them may be connected to their local account.</para>
          
          <section xml:id="section_sp_checkConnections">
              <title>Obtaining a provider API from a connection</title>
              
              <para>Once you have one or more <interfacename>ServiceProviderConnection</interfacename>s, you may access the provider API by calling <methodname>getServiceApi()</methodname>. For example, suppose that you're working with <classname>FacebookServiceProvider</classname>. Here's how you might get an instance of <interfacename>FacebookOperations</interfacename> so that you may interact with Facebook on behalf of a user:</para>
              
              <programlisting><![CDATA[FacebookOperations facebook = facebookProvider.getConnections(accountId).get(0).getServiceApi();]]></programlisting>
              
              <para>Here, the <methodname>getServiceApi()</methodname> method is being called for the first of the connections returned from <methodname>getConnections()</methodname>. In the case of <classname>FacebookServiceProvider</classname>, the service API is defined by the <interfacename>FacebookOperations</interfacename> interface, which is covered in detail in <xref linkend="facebook"/>.</para>
          </section>      
          
          
          <section xml:id="section_sp_connect">
              <title>Creating connections through a service provider</title>
              <para>In addition to the core methods of <interfacename>ServiceProvider</interfacename>, a service provider implementation will give you a <methodname>connect()</methodname> method for creating a connection. The <methodname>connect()</methodname> will vary depending on whether you are working with an OAuth 1-based service provider or an OAuth 2-based service provider. For an OAuth 1 service provider, the <methodname>connect()</methodname> signature is:</para>

              <programlisting><![CDATA[ServiceProviderConnection<S> connect(Serializable accountId, OAuthToken accessToken);]]></programlisting>
              
              <para>To create a connection with an OAuth 1 provider, call it, passing in a local application account ID and an access token that was granted for the profile to be connected to:</para>
              
              <programlisting><![CDATA[ServiceProviderConnection<?> connection = provider.connect(accountId, new OAuthToken(token, secret));]]></programlisting>
              
      		
              <para>The <classname>OAuthToken</classname> is created given an access token value and the access token secret.</para>
              
              <para>For an OAuth 2 service provider, the <methodname>connect()</methodname> signature is slightly different:</para>

              <programlisting><![CDATA[ServiceProviderConnection<S> connect(Serializable accountId, AccessGrant accessToken);]]></programlisting>
              
              <para>OAuth 2 access tokens are not paired with an access token secret. They may, however, come with a refresh token. Therefore, to create a connection with an OAuth 2 provider profile:</para>
              
              <programlisting><![CDATA[ServiceProviderConnection<?> connection = provider.connect(accountId, new AccessGrant(accessToken, refreshToken));]]></programlisting>              
              
              <para>In either case, using these methods assumes that you have already gone through the OAuth dance and have obtained an access token. Since the OAuth authorization flow is non-trivial, it's typically best to take advantage of Spring Social's <classname>ConnectController</classname> (described in <xref linkend="connect-controller"/>) to handle OAuth authorization and the creation of connections.</para>
          </section>
      </section>
      
      <section xml:id="section_sp_oauthOperations">
          <title>OAuth Operations</title>
          
          <para>TODO</para>
      </section>
  </section>
</chapter>
