<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="serviceprovider"
    xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Service Providers</title>

  <section xml:id="section_serviceprovider_introduction">
      <title>Introduction</title>
      
      <para>A service provider enables an application to manage connections between a user's local account and their account on the service. The service provider also exposes an API that the application may use to access the user's private data on the provider.In Spring Social, a service provider is modeled by the <interfacename>ServiceProvider</interfacename> interface:</para>

<programlisting><![CDATA[
public interface ServiceProvider<S> {
	String getId();
	boolean isConnected(Serializable accountId);
	List<ServiceProviderConnection<S>> getConnections(Serializable accountId);
}]]></programlisting>

      <para>Spring Social comes with several ready-to-use service provider implementations:</para>

        <itemizedlist>
            <listitem><para><classname>org.springframework.social.facebook.connect.FacebookServiceProvider</classname></para></listitem>
            <listitem><para><classname>org.springframework.social.twitter.connect.TwitterServiceProvider</classname></para></listitem>
            <listitem><para><classname>org.springframework.social.linkedin.connect.LinkedInServiceProvider</classname></para></listitem>
            <listitem><para><classname>org.springframework.social.tripit.connect.TripItServiceProvider</classname></para></listitem>
            <listitem><para><classname>org.springframework.social.github.connect.GitHubServiceProvider</classname></para></listitem>
            <listitem><para><classname>org.springframework.social.gowalla.connect.GowallaServiceProvider</classname></para></listitem>
                                </itemizedlist>

        <para>You may also create your own service providers by implementing the <interfacename>ServiceProvider</interfacename> interface or extending one of the abstract classes that model the interaction specific to a specific version of OAuth: <classname>AbstractOAuth1ServiceProvider</classname> or <classname>AbstractOAuth2ServiceProvider</classname>.</para>
                  
  </section>

    <section xml:id="section_usingserviceproviders">
        <title>Using Service Providers</title>

        <para>There are a handful of useful things you can do with the service provider, including:</para>

        <itemizedlist>
            <listitem><para>Manage connections between an application account and a provider profile.</para></listitem>
            <listitem><para>Access provider API for interacting with the service provider on behalf of the user.</para></listitem>
            <listitem><para>Perform OAuth authorization with the service provider.</para></listitem>
        </itemizedlist>

        <section xml:id="section_sp_manageConnections">
            <title>Managing provider connections</title>

            <para>The <interfacename>ServiceProvider</interfacename> interface provides methods for managing connections between an application account and a user's profile at the provider:</para>

            <programlisting><![CDATA[boolean isConnected(Serializable accountId);
List<ServiceProviderConnection<S>> getConnections(Serializable accountId);]]></programlisting>

            <para>The <methodname>isConnected()</methodname> method is useful for determining if any connections have been made between the user's application account (specified with the account ID) and the provider.</para>

            <para>To work with the connections themselves, call the <methodname>getConnections()</methodname> method. Notice that this method returns a list of <interfacename>ServiceProviderConnection</interfacename>s and not a single connection. That's because it is possible for a user to connect their account with multiple profiles on the provider. For example, if a user has multiple Twitter profiles, any one or all of them may be connected to their local account.</para>

            <section xml:id="section_sp_checkConnections">
                <title>Obtaining a provider API from a connection</title>

                <para>Once you have one or more <interfacename>ServiceProviderConnection</interfacename>s, you may access the provider API by calling <methodname>getServiceApi()</methodname>. For example, suppose that you're working with <classname>FacebookServiceProvider</classname>. Here's how you might get an instance of <interfacename>FacebookOperations</interfacename> so that you may interact with Facebook on behalf of a user:</para>

                <programlisting><![CDATA[FacebookOperations facebook = facebookProvider.getConnections(accountId).get(0).getServiceApi();]]></programlisting>

                <para>Here, the <methodname>getServiceApi()</methodname> method is being called for the first of the connections returned from <methodname>getConnections()</methodname>. In the case of <classname>FacebookServiceProvider</classname>, the service API is defined by the <interfacename>FacebookOperations</interfacename> interface, which is covered in detail in <xref linkend="facebook"/>.</para>
            </section>      


            <section xml:id="section_sp_connect">
                <title>Creating connections through a service provider</title>
                <para>In addition to the core methods of <interfacename>ServiceProvider</interfacename>, a service provider implementation will give you a <methodname>connect()</methodname> method for creating a connection. The <methodname>connect()</methodname> will vary depending on whether you are working with an OAuth 1-based service provider or an OAuth 2-based service provider. For an OAuth 1 service provider, the <methodname>connect()</methodname> signature is:</para>

                <programlisting><![CDATA[ServiceProviderConnection<S> connect(Serializable accountId, OAuthToken accessToken);]]></programlisting>

                <para>To create a connection with an OAuth 1 provider, call it, passing in a local application account ID and an access token that was granted for the profile to be connected to:</para>

                <programlisting><![CDATA[ServiceProviderConnection<?> connection = provider.connect(accountId, new OAuthToken(token, secret));]]></programlisting>


                <para>The <classname>OAuthToken</classname> is created given an access token value and the access token secret.</para>

                <para>For an OAuth 2 service provider, the <methodname>connect()</methodname> signature is slightly different:</para>

                <programlisting><![CDATA[ServiceProviderConnection<S> connect(Serializable accountId, AccessGrant accessToken);]]></programlisting>

                <para>OAuth 2 access tokens are not paired with an access token secret. They may, however, come with a refresh token. Therefore, to create a connection with an OAuth 2 provider profile:</para>

                <programlisting><![CDATA[ServiceProviderConnection<?> connection = provider.connect(accountId, new AccessGrant(accessToken, refreshToken));]]></programlisting>              

                <para>In either case, using these methods assumes that you have already gone through the OAuth dance and have obtained an access token. Since the OAuth authorization flow is non-trivial, it's typically best to take advantage of Spring Social's <classname>ConnectController</classname> (described in <xref linkend="connect-controller"/>) to handle OAuth authorization and the creation of connections.</para>
            </section>
        </section>
    </section>
    
  <section xml:id="section_serviceproviderconfig">
      <title>Configuring Service Providers</title>
      
      <para>You can configure a service provider in the Spring application context using Spring Social's Spring configuration namespace:</para>
      
      <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:social="http://www.springframework.org/schema/spring-social"
    xsi:schemaLocation="http://www.springframework.org/schema/spring-social 
             http://www.springframework.org/schema/social/spring-social-1.0.xsd
        http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
        
    ...
</beans>]]></programlisting>

      <para>The <code><![CDATA[<social:service-provider>]]></code> element can be used to configure any service provider in Spring. For example, to configure a Twitter provider:</para>
      
<programlisting><![CDATA[<social:service-provider 
    class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
    client-key="..." 
    client-secret="..." />]]></programlisting>

      <para>The <code>class</code> attribute specifies the fully-qualified name of the provider implementation. This can be any of the service provider implementations that come with Spring Social or a custom implementation. The <code>client-key</code> and <code>client-secret</code> attributes specify the key and secret values assigned to your application when you registered it with the provider.</para>

      <section xml:id="section_config_connectionrepository">
          <title>Connection Repository</title>
          
          <para>When a service provider creates a connection, the connection details must be persisted somewhere for future use. The service provider relies on a connection repository for persistence of connection Spring Social comes with <classname>JdbcConnectionRepository</classname>, a connection repository that persists connections to a relational database via JDBC. The following XML shows how to configure a <classname>JdbcConnectionRepository</classname> bean:</para>
          
          <programlisting><![CDATA[<bean id="connectionRepository" class="org.springframework.social.connect.jdbc.JdbcConnectionRepository">
    <constructor-arg ref="dataSource" />
    <constructor-arg ref="textEncryptor" />
</bean>]]></programlisting>

          <para><classname>JdbcConnectionRepository</classname> is constructed with a reference to a <classname>DataSource</classname> through which it will communicate with the database and a <interfacename>TextEncryptor</interfacename> that it will use to encrypt/decrypt sensitive connection details (such as access tokens and secrets).</para>
          
          <para>The <interfacename>TextEncryptor</interfacename> is defined in Spring Security 3.1 in the <code>org.springframework.security.crypto.encrypt</code> package. Spring Security 3.1 also includes an <classname>Encryptors</classname> class which acts as a factory for common encryptor implementations. For example, to configure a no-op text encryptor (one that doesn't perform any encryption at all):</para>

          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" />]]></programlisting>
          
          <para>Or, to configure a text encryptor that uses standard password-based encryption:</para>
          
          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="text">
    <constructor-arg value="password"/>
    <constructor-arg value="salt"/>    
</bean>]]></programlisting>

          <para>Note that the ID of the connection repository bean is significant. By default, the <code><![CDATA[<social:service-provider>]]></code> element will assume that the connection repository bean's ID is "connectionRepository". If, however, you give the connection repository bean a different ID, then you'll need to explicitly specify the connection repository when configuring a <code><![CDATA[<social:service-provider>]]></code>:</para>

          <programlisting><![CDATA[<social:service-provider 
              class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
              client-key="..." 
              client-secret="..."
              connection-repository="connectionStorage" />]]></programlisting>
              
              
          <para><code>JdbcConnectionRepository</code> assumes that a <code>Connection</code> table exists and was created as follows:</para>
          
<programlisting><![CDATA[create table Connection (id identity,
			accountId varchar not null,
			providerId varchar not null,
			accessToken varchar not null,					
			secret varchar, 
			refreshToken varchar,
			primary key (id));
create unique index AccessToken on Connection(accountId, providerId, accessToken);]]></programlisting>

          <para>For convenience sake, SQL is available in Spring Social's core module as a resource: /org/springframework/social/connect/jdbc/ConnectionRepositorySchema.sql.</para>
      </section>
  </section>

  <section xml:id="section_newserviceprovider">
      <title>Extending Spring Social with custom service providers</title>
      
      <para>Even though Spring Social only comes with a handful of service provider implementations, you can easily extend Spring Social's reach into other services by creating a custom service provider implementation.</para>
      
      <para>The first step in creating a new service provider implementation is to determine what kind of authorization the service requires. Spring Social provides abstract service provider classes for both OAuth 1 and OAuth 2-based services in <classname>AbstractOAuth1ServiceProvider</classname> and <classname>AbstractOAuth1ServiceProvider</classname>, respectively. If your service uses some authorization mechanism other than OAuth, you may choose to base your service provider on <classname>AbstractServiceProvider</classname> instead.</para>
      
      <para>To understand how this works, have a look at how some of the existing service provider implementations have been created. For example, consider <classname>TwitterServiceProvider</classname> as an example of how to develop an OAuth 1-based service provider:</para>
      
      <programlisting><![CDATA[package org.springframework.social.twitter.connect;

import org.springframework.social.connect.oauth1.AbstractOAuth1ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.oauth1.OAuth1Template;
import org.springframework.social.twitter.TwitterOperations;
import org.springframework.social.twitter.TwitterTemplate;

/**
* Twitter ServiceProvider implementation.
* @author Keith Donald
* @author Craig Walls
*/
public final class TwitterServiceProvider extends AbstractOAuth1ServiceProvider<TwitterOperations> {

	public TwitterServiceProvider(String consumerKey, String consumerSecret, ConnectionRepository connectionRepository) {
		super("twitter", connectionRepository, consumerKey, consumerSecret, 
		    new OAuth1Template(consumerKey, consumerSecret, 
		        "https://twitter.com/oauth/request_token",
				"https://twitter.com/oauth/authorize?oauth_token={requestToken}", 
				"https://twitter.com/oauth/access_token"));
	}

	@Override
	protected TwitterOperations getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {
		return new TwitterTemplate(consumerKey, consumerSecret, accessToken, secret);
	}

}]]></programlisting>
      
      <para>The first thing to note is that <classname>TwitterServiceProvider</classname> extends <classname>AbstractOAuth1ServiceProvider</classname>, parameterized with <interfacename>TwitterOperations</interfacename>. This indicates that <classname>TwitterServiceProvider</classname> is an OAuth 1-based provider and that its service API is a <interfacename>TwitterOperations</interfacename>.</para>
      
      <para><classname>TwitterServiceProvider</classname>'s constructor is given the provider's consumer key and secret along with a connection repository for persisting connection details. It calls the super constructor, passing the provider's ID, the connection repository, the consumer key and secret, and an instance of <classname>OAuth1Template</classname> that will be used to perform the authorization calls to Twitter.</para>
      
      <para>The <classname>OAuth1Template</classname> itself is constructed with the consumer key and secret, along with Twitter's request token URL, authorization URL, and access token URL. Note that the authorization URL is parameterized and must have a "requestToken" placeholder.</para>
      
      <para>In addition to the constructor, a subclass of <classname>AbstractOAuth1ServiceProvider</classname> must also override the <methodname>getApi()</methodname>. This method's job is to return an instance of the service API. In this case, it uses the consumer key and secret and the access token and secret to instantiate a <classname>TwitterTemplate</classname>.</para>
      
      <para>If you have a look at some of the other OAuth 1-based service providers in Spring Social, you'll see that they aren't much different than this one, aside from their ID, their OAuth 1 URLs, and their service API.</para>
      
      <para>Speaking of the service API, that's the one other thing you'll need to write in order to create a new service provider. In the case of <classname>TwitterServiceProvider</classname>, the service API is defined by the <interfacename>TwitterOperations</interfacename> interface and <classname>TwitterTemplate</classname> implementation of that interface.</para>
      
      <para>An OAuth 2 service provider implementation is only slightly different than an OAuth 1 service provider, as you can see by looking at <classname>FacebookServiceProvider</classname>:</para>
      
      <programlisting><![CDATA[package org.springframework.social.facebook.connect;

import org.springframework.social.connect.oauth2.AbstractOAuth2ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.facebook.FacebookOperations;
import org.springframework.social.facebook.FacebookTemplate;
import org.springframework.social.oauth2.OAuth2Template;

public final class FacebookServiceProvider extends AbstractOAuth2ServiceProvider<FacebookOperations> {

	public FacebookServiceProvider(String clientId, String clientSecret, ConnectionRepository connectionRepository) {
		super("facebook",connectionRepository, 
		    new OAuth2Template(clientId, clientSecret,
			    "https://graph.facebook.com/oauth/authorize?client_id={client_id}&redirect_uri={redirect_uri}&scope={scope}", 
                "https://graph.facebook.com/oauth/access_token"));
	}

	@Override
	protected FacebookOperations getApi(String accessToken) {
		return new FacebookTemplate(accessToken);
	}

}]]></programlisting>
      
      <para>The key difference is that <classname>FacebookServiceProvider</classname> extends <classname>AbstractOAuth2ServiceProvider</classname> instead of <classname>AbstractOAuth1ServiceProvider</classname>. Its constructor is given the client ID and client secret (the OAuth 2 equivalent of consumer key and consumer secret) and the connection repository. It uses them to call the super constructor with the provider ID, the connection repository, and an instance of <classname>OAuth2Template</classname> to conduct the OAuth 2 exchange with Facebook.</para>
      
      <para>The <classname>OAuth2Template</classname> is constructed much like <classname>OAuth1Template</classname> except that it doesn't need a request token URL. Also, the authorization URL is parameterized with "client_id", "redirect_uri", and "scope".</para>
      
      <para>Finally, the <methodname>getApi()</methodname> is given only the access token needed to construct <classname>FacebookTemplate</classname>.</para>
      
      <para>Again, if you compare <classname>FacebookServiceProvider</classname> with some of the other OAuth 2 service provider implementations (e.g., <classname>GitHubServiceProvider</classname> and <classname>GowallaServiceProvider</classname>), you'll see that they're all quite similar with the key difference being their IDs, service APIs, and OAuth 2 URLs.</para>
  </section>
</chapter>
