<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="serviceprovider"
    xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Service Providers</title>

  <section xml:id="section_serviceprovider_introduction">
      <title>Introduction</title>
      
      <para>In <xref linkend="apis"/>, you'll see how Spring Social provides APIs through which your application may interact with various service providers. But before you can work with a service API, your application must be authorized to access the service on the user's behalf.</para>
      
      <para>Spring Social's service provider framework handles the details of authorization with a service. Once authorization has been granted, a connection is created between the user's local application account and the authorization credentials. This connection is persisted for future use, so that the user won't need to re-authorize the application as long as the credentials are still valid.</para>
      
      <para>The central concept in the service provider framework is the service provider. A service provider represents a service that the application wants to interact with on its users' behalf. The service provider maintains the applications own credentials with the service and is able to negotiate permissions for the application to access the service.</para>
      
      <para>Spring Social supports two authorization protocols: OAuth 1 and OAuth 2. Both of these protocols achieve essentially the same thing: They enable a user to grant permission for a consumer to access their data and perform actions on a provider. That permission is manifested as an access token that serves as a sort of valet key that can be used in place of a user's own credentials to access a service.</para>
          
      <para>Although conceptually similar, each of these protocols arrive at an access token in a slightly different way. The OAuth 1 flow is illustrated as follows:</para>
      
      <mediaobject>
        <imageobject role="fo">
            <imagedata fileref="images/oauth1_flow.png"
              format="PNG" align="center" scale="70"/>
        </imageobject>
        <imageobject role="html">
            <imagedata fileref="images/oauth1_flow.png" format="PNG" align="center" scale="70"/>
        </imageobject>
      </mediaobject>

      <para>As you can see, there is a back-and-forth conversation that takes place between the consumer and the service provider to establish authorization for the consumer. This exchange, commonly known as the "OAuth Dance", follows these steps:</para>
      
      <orderedlist>
          <listitem><para>The flow starts with the consumer asking for a request token. A request token's purpose is to obtain user approval and can only be used to obtain an access token. In OAuth 1.0a, the consumer callback URL is passed to the provider when asking for a request token.</para></listitem>
          <listitem><para>The service provider issues a request token to the consumer.</para></listitem>
          <listitem><para>The consumer redirects the user's browser to the provider's authorization page, passing the request token as a parameter. In OAuth 1.0, the callback URL is also passed as a parameter in this step.</para></listitem>
          <listitem><para>The service provider prompts the user to authorize the consumer application and the user agrees. (Note that this is the only step where the user participates in the flow.)</para></listitem>
          <listitem><para>The service provider redirects the user's browser back to a callback URL on the consumer. In OAuth 1.0a, this redirect includes a verifier code as a parameter. At this point, the request token is authorized.</para></listitem>
          <listitem><para>The consumer exchanges the request token (and the verifier in OAuth 1.0a) for an access token.</para></listitem>
          <listitem><para>The service provider issues an access token to the consumer. The "dance" is complete.</para></listitem>
          <listitem><para>The consumer makes calls against the service API, passing the access token along as evidence of its right to access the provider on behalf of the user.</para></listitem>
      </orderedlist>

      <para>The OAuth 2 authorization flow differs only slightly from the OAuth 1 flow, as illustrated here:</para>

      <mediaobject>
        <imageobject role="fo">
            <imagedata fileref="images/oauth2_flow.png"
              format="PNG" align="center" scale="70"/>
        </imageobject>
        <imageobject role="html">
            <imagedata fileref="images/oauth2_flow.png" format="PNG" align="center" scale="0"/>
        </imageobject>
      </mediaobject>
      
      <para>The steps in the OAuth 2 dance are as follows:</para>
      
      <orderedlist>
          <listitem><para>The flow starts with the consumer redirecting the user's browser to the provider's authorization page. Unlike OAuth 1, there is no concept of request token in OAuth 2.</para></listitem>
          <listitem><para>The service provider prompts the user to authorize the consumer application and the user agrees. (As with OAuth 1, this is the only step where the user participates in the flow.)</para></listitem>
          <listitem><para>The service provider redirects the user's browser to the consumer's redirect URI, with an authorization code as a parameter.</para></listitem>
          <listitem><para>The consumer exchanges the authorization code for an access token.</para></listitem>
          <listitem><para>The service provider issues an access token to the consumer. The "dance" is complete.</para></listitem>
          <listitem><para>The consumer makes calls against the service API, passing the access token along as evidence of its right to access the provider on behalf of the user.</para></listitem>
      </orderedlist>  
      
      <para>In Spring Social, service providers are defined by the <interfacename>ServiceProvider</interfacename> interface, which defined the basic operations required to manage connections with a service:</para>
      
<programlisting><![CDATA[public interface ServiceProvider<S> {
	String getId();
	boolean isConnected(Serializable accountId);
	List<ServiceProviderConnection<S>> getConnections(Serializable accountId);
}]]></programlisting>

      <para>Each service provider is identified by an ID, as returned by the <methodname>getId()</methodname> method. This ID is primarily used as a key to lookup a service provider when working through the authorization flow.</para>
      
      <para>A user may authorize the application to access multiple service provider profiles, resulting in one or more connections being created between their application account and the service provider. The <methodname>isConnected()</methodname> checks to see if any connections exist between a given account and the provider. If there are any connections, the <methodname>getConnections()</methodname> will return them.</para>

      <para>The <interfacename>ServiceProvider</interfacename> is further defined by two sub-interfaces, one for each supported authorization protocol. <interfacename>OAuth1ServiceProvider</interfacename> defines the service provider operations that are specific to OAuth 1:</para>
      
<programlisting><![CDATA[public interface OAuth1ServiceProvider<S> extends ServiceProvider<S> {
	OAuth1Operations getOAuth1Operations();
	ServiceProviderConnection<S> connect(Serializable accountId, OAuthToken accessToken);
}]]></programlisting>

      <para>Likewise, <interfacename>OAuth2ServiceProvider</interfacename> defines service provider operations that pertain to OAuth 2:</para>
      
<programlisting><![CDATA[public interface OAuth2ServiceProvider<S> extends ServiceProvider<S> {
    OAuth2Operations getOAuth2Operations();
    ServiceProviderConnection<S> connect(Serializable accountId, AccessGrant accessToken);
}]]></programlisting>
      
      <para>As you can see, these two sub-interfaces are quite similar, but differ slightly to accommodate the differences in each authorization protocol. The most significant method in each interface is the <methodname>connect()</methodname> which creates a connection given a user's account ID and the authorization credentials. The other method returns an operations API for working with each authorization protocol at a low level.</para>
      
      <para>Generally, application code will not work with these interfaces directly. Instead, you'll leverage Spring Social's <classname>ConnectController</classname> (see <xref linkend="connecting"/>) to handle the authorization flow for you. You may, however, use the <methodname>getConnections()</methodname> to access the service API for a given connection. This will be covered in more detail in <xref linkend="apis"/>.</para>
  </section>


  <section xml:id="section_serviceproviderconfig">
      <title>Configuring Service Providers</title>
      
      <para>Working with the service provider framework starts with configuring the service provider in Spring. Spring Social's configuration namespace provides a convenient <code><![CDATA[<social:service-provider>]]></code> element for declaring a service provider:</para>
      
      <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:social="http://www.springframework.org/schema/spring-social"
    xsi:schemaLocation="http://www.springframework.org/schema/spring-social 
             http://www.springframework.org/schema/social/spring-social-1.0.xsd
        http://www.springframework.org/schema/beans 
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

<social:service-provider 
    class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
    client-key="..." 
    client-secret="..." />        
</beans>]]></programlisting>

      <para>The <code>class</code> attribute specifies the fully-qualified name of the provider implementation. This can be any of the service provider implementations that come with Spring Social or a custom implementation. Spring Social comes with the following service provider implementations:</para>

      <itemizedlist>
          <listitem><para>org.springframework.social.facebook.connect.FacebookServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.twitter.connect.TwitterServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.linkedin.connect.LinkedInServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.tripit.connect.TripItServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.github.connect.GitHubServiceProvider</para></listitem>
          <listitem><para>org.springframework.social.gowalla.connect.GowallaServiceProvider</para></listitem>
      </itemizedlist>
      
      <para>The <code>client-key</code> and <code>client-secret</code> attributes specify the key and secret values assigned to your application when you registered it with the provider.</para>

      <section xml:id="section_config_connectionrepository">
          <title>Connection Repository</title>
          
          <para>When a service provider creates a connection, the connection details must be persisted somewhere for future use. The service provider relies on a connection repository for persistence of connection Spring Social comes with <classname>JdbcConnectionRepository</classname>, a connection repository that persists connections to a relational database via JDBC. The following XML shows how to configure a <classname>JdbcConnectionRepository</classname> bean:</para>
          
          <programlisting><![CDATA[<bean id="connectionRepository" class="org.springframework.social.connect.jdbc.JdbcConnectionRepository">
    <constructor-arg ref="dataSource" />
    <constructor-arg ref="textEncryptor" />
</bean>]]></programlisting>

          <para><classname>JdbcConnectionRepository</classname> is constructed with a reference to a <classname>DataSource</classname> through which it will communicate with the database and a <interfacename>TextEncryptor</interfacename> that it will use to encrypt/decrypt sensitive connection details (such as access tokens and secrets).</para>
          
          <para>The <interfacename>TextEncryptor</interfacename> is defined in Spring Security 3.1 in the <code>org.springframework.security.crypto.encrypt</code> package. Spring Security 3.1 also includes an <classname>Encryptors</classname> class which acts as a factory for common encryptor implementations. For example, to configure a no-op text encryptor (one that doesn't perform any encryption at all):</para>

          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="noOpText" />]]></programlisting>
          
          <para>Or, to configure a text encryptor that uses standard password-based encryption:</para>
          
          <programlisting><![CDATA[<bean id="textEncryptor" class="org.springframework.security.crypto.encrypt.Encryptors" factory-method="text">
    <constructor-arg value="password"/>
    <constructor-arg value="salt"/>    
</bean>]]></programlisting>

          <para>Note that the ID of the connection repository bean is significant. By default, the <code><![CDATA[<social:service-provider>]]></code> element will assume that the connection repository bean's ID is "connectionRepository". If, however, you give the connection repository bean a different ID, then you'll need to explicitly specify the connection repository when configuring a <code><![CDATA[<social:service-provider>]]></code>:</para>

          <programlisting><![CDATA[<social:service-provider 
              class="org.springframework.social.twitter.connect.TwitterServiceProvider" 
              client-key="..." 
              client-secret="..."
              connection-repository="connectionStorage" />]]></programlisting>
              
              
          <para><code>JdbcConnectionRepository</code> assumes that a <code>Connection</code> table exists and was created as follows:</para>
          
<programlisting><![CDATA[create table Connection (id identity,
			accountId varchar not null,
			providerId varchar not null,
			accessToken varchar not null,					
			secret varchar, 
			refreshToken varchar,
			primary key (id));
create unique index AccessToken on Connection(accountId, providerId, accessToken);]]></programlisting>

          <para>For convenience sake, SQL is available in Spring Social's core module as a resource: /org/springframework/social/connect/jdbc/ConnectionRepositorySchema.sql.</para>
      </section>
  </section>

  <section xml:id="section_newserviceprovider">
      <title>Extending Spring Social with custom service providers</title>
      
      <para>Even though Spring Social only comes with a handful of service provider implementations, you can easily extend Spring Social's reach into other services by creating a custom service provider implementation.</para>
      
      <para>The first step in creating a new service provider implementation is to determine what kind of authorization the service requires. Spring Social provides abstract service provider classes for both OAuth 1 and OAuth 2-based services in <classname>AbstractOAuth1ServiceProvider</classname> and <classname>AbstractOAuth1ServiceProvider</classname>, respectively. If your service uses some authorization mechanism other than OAuth, you may choose to base your service provider on <classname>AbstractServiceProvider</classname> instead.</para>
      
      <para>To understand how this works, have a look at how some of the existing service provider implementations have been created. For example, consider <classname>TwitterServiceProvider</classname> as an example of how to develop an OAuth 1-based service provider:</para>
      
      <programlisting><![CDATA[package org.springframework.social.twitter.connect;

import org.springframework.social.connect.oauth1.AbstractOAuth1ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.oauth1.OAuth1Template;
import org.springframework.social.twitter.TwitterOperations;
import org.springframework.social.twitter.TwitterTemplate;

public final class TwitterServiceProvider extends AbstractOAuth1ServiceProvider<TwitterOperations> {

	public TwitterServiceProvider(String consumerKey, String consumerSecret, ConnectionRepository connectionRepository) {
		super("twitter", connectionRepository, consumerKey, consumerSecret, 
		    new OAuth1Template(consumerKey, consumerSecret, 
		        "https://twitter.com/oauth/request_token",
				"https://twitter.com/oauth/authorize?oauth_token={requestToken}", 
				"https://twitter.com/oauth/access_token"));
	}

	@Override
	protected TwitterOperations getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {
		return new TwitterTemplate(consumerKey, consumerSecret, accessToken, secret);
	}

}]]></programlisting>
      
      <para>The first thing to note is that <classname>TwitterServiceProvider</classname> extends <classname>AbstractOAuth1ServiceProvider</classname>, parameterized with <interfacename>TwitterOperations</interfacename>. This indicates that <classname>TwitterServiceProvider</classname> is an OAuth 1-based provider and that its service API is a <interfacename>TwitterOperations</interfacename>.</para>
      
      <para><classname>TwitterServiceProvider</classname>'s constructor is given the provider's consumer key and secret along with a connection repository for persisting connection details. It calls the super constructor, passing the provider's ID, the connection repository, the consumer key and secret, and an instance of <classname>OAuth1Template</classname> that will be used to perform the authorization calls to Twitter.</para>
      
      <para>The <classname>OAuth1Template</classname> itself is constructed with the consumer key and secret, along with Twitter's request token URL, authorization URL, and access token URL. Note that the authorization URL is parameterized and must have a "requestToken" placeholder.</para>
      
      <para>In addition to the constructor, a subclass of <classname>AbstractOAuth1ServiceProvider</classname> must also override the <methodname>getApi()</methodname>. This method's job is to return an instance of the service API. In this case, it uses the consumer key and secret and the access token and secret to instantiate a <classname>TwitterTemplate</classname>.</para>
      
      <para>If you have a look at some of the other OAuth 1-based service providers in Spring Social, you'll see that they aren't much different than this one, aside from their ID, their OAuth 1 URLs, and their service API.</para>
      
      <para>Speaking of the service API, that's the one other thing you'll need to write in order to create a new service provider. In the case of <classname>TwitterServiceProvider</classname>, the service API is defined by the <interfacename>TwitterOperations</interfacename> interface and <classname>TwitterTemplate</classname> implementation of that interface.</para>
      
      <para>An OAuth 2 service provider implementation is only slightly different than an OAuth 1 service provider, as you can see by looking at <classname>FacebookServiceProvider</classname>:</para>
      
      <programlisting><![CDATA[package org.springframework.social.facebook.connect;

import org.springframework.social.connect.oauth2.AbstractOAuth2ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.facebook.FacebookOperations;
import org.springframework.social.facebook.FacebookTemplate;
import org.springframework.social.oauth2.OAuth2Template;

public final class FacebookServiceProvider extends AbstractOAuth2ServiceProvider<FacebookOperations> {

	public FacebookServiceProvider(String clientId, String clientSecret, ConnectionRepository connectionRepository) {
		super("facebook",connectionRepository, 
		    new OAuth2Template(clientId, clientSecret,
			    "https://graph.facebook.com/oauth/authorize?client_id={client_id}&redirect_uri={redirect_uri}&scope={scope}", 
                "https://graph.facebook.com/oauth/access_token"));
	}

	@Override
	protected FacebookOperations getApi(String accessToken) {
		return new FacebookTemplate(accessToken);
	}

}]]></programlisting>
      
      <para>The key difference is that <classname>FacebookServiceProvider</classname> extends <classname>AbstractOAuth2ServiceProvider</classname> instead of <classname>AbstractOAuth1ServiceProvider</classname>. Its constructor is given the client ID and client secret (the OAuth 2 equivalent of consumer key and consumer secret) and the connection repository. It uses them to call the super constructor with the provider ID, the connection repository, and an instance of <classname>OAuth2Template</classname> to conduct the OAuth 2 exchange with Facebook.</para>
      
      <para>The <classname>OAuth2Template</classname> is constructed much like <classname>OAuth1Template</classname> except that it doesn't need a request token URL. Also, the authorization URL is parameterized with "client_id", "redirect_uri", and "scope".</para>
      
      <para>Finally, the <methodname>getApi()</methodname> is given only the access token needed to construct <classname>FacebookTemplate</classname>.</para>
      
      <para>Again, if you compare <classname>FacebookServiceProvider</classname> with some of the other OAuth 2 service provider implementations (e.g., <classname>GitHubServiceProvider</classname> and <classname>GowallaServiceProvider</classname>), you'll see that they're all quite similar with the key difference being their IDs, service APIs, and OAuth 2 URLs.</para>
  </section>
</chapter>
